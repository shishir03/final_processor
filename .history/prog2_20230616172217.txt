lb r0 00101
mov r15 r0
lbr r2
addi r0 00000
lbr r3
mov r0 r2
mov r5 r0
mov r0 r3
mov r6 r0               // r5 = r2 = LSB, r6 = r3 = MSB
lb r0 01000
mov r14 r0
lb r1 00110             // shift loop start (16x iterations) - r1 loads bitmask
mov r0 r3
and r1                  // r1 = leftmost bit
mov r0 r4
xor r4                  // r4 keeps track of total xor
mov r0 r2               // left shift
lsl r2
mov r0 r3
lsl r3
lb r1 00111
mov r0 r14
addi r0 00000
mov r14 r0
blt 0001
mov r0 r4
lb r1 01000
beq next                // is the xor 0? (i.e. is the message error-free)
mov r0 r5
lb r1 01001
and r0
rxor r0
mov r0 r6
rxor r0
lb r1 01000
bne next                // does p0 = 0? (if so, there are 2 errors)
lb r0 01001
not r7
mov r0 r15
subi r0 00001
sbr r7
lb r0 01000
lb r1 01000
beq end                // unconditional branch
mov r0 r6              // .next
lsr r6
lb r1 01010            // mask for b1 of the original message
mov r0 r5
and r0                 // gets b1
lsl r0
xor r5
lb r1 01100            // zeroes out parity bits
mov r0 r5
xor r0
mov r1 r6
lsr r1
lsr r0
lsr r1
lsr r0
lsr r1
lsr r0
lsr r1
lsr r0
mov r5 r0
mov r6 r1
lb r1 01000
mov r0 r4
bne end                // check for rxor of 0 (if so, error correcting can be skipped)
lb r1 01011
mov r0 r6
xor r0                 // set single error flag for MSB
lb r1 01101
mov r9 r1

